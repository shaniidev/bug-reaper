# Exploit Validation — Attacker-Controlled Input Tracing

Use this methodology to validate whether a potential finding is actually exploitable. A finding without a proven exploit path stays **Theoretical**.

## The Validation Process

For every potential vulnerability, trace this chain completely:

```
Attacker Input → Entry Point → [Validation Points] → Sink
```

Each step must be verified. A break anywhere in the chain = downgrade or discard.

## Step 1 — Identify the Entry Point

Where does attacker-controlled input enter the application?

| Entry Type | Examples |
|---|---|
| URL parameter | `?id=`, `?q=`, `?redirect=` |
| POST body | JSON/form fields |
| HTTP headers | `Referer`, `X-Forwarded-For`, `Origin`, `User-Agent`, custom headers |
| Path segments | `/user/<id>/profile` |
| File upload | Filename, content, MIME type |
| Websocket message | Any field in WS payload |
| Cookie value | Session tokens, preference cookies |
| GraphQL variables | `$input`, fragments |

**Confirm:** Is this input actually attacker-controlled without requiring admin/server compromise?

## Step 2 — Map Validation and Sanitization Points

Between entry and sink, list every security control on the data path:

| Control Type | Examples | Effect |
|---|---|---|
| Input validation | Allowlist/blocklist check, regex | May block payload |
| Output encoding | HTML entities, URL encode, JSON escape | Prevents most XSS |
| Parameterization | Prepared statements, ORM | Prevents SQLi |
| WAF/firewall | Pattern matching | May block specific payloads |
| Framework auto-protection | Django CSRF, React JSX auto-escape | Often bulletproof |
| Type coercion/casting | `parseInt()`, `(int)$x` | Limits injection |
| Length limits | Max field length | May prevent long payloads |

**For each control: does the attacker's payload survive it intact? If ANY control neutralizes the payload → the path is broken.**

## Step 3 — Identify the Dangerous Sink

Where does the data land that causes impact?

| Sink Type | Vulnerability | Example |
|---|---|---|
| SQL query string | SQLi | `WHERE id = '$input'` |
| HTML output without encoding | XSS | `innerHTML = input` |
| HTTP request origin | SSRF | `fetch(userURL)` |
| File path | Path traversal | `open('/data/' + input)` |
| Shell command | RCE | `exec('ping ' + input)` |
| Template render | SSTI | `render(input)` |
| Deserialization | RCE/object injection | `pickle.loads(input)` |
| Redirect target | Open redirect | `redirect(input)` |
| Database row read | IDOR | `SELECT * WHERE user_id = input` |

## Step 4 — Identify Trust Boundaries Crossed

A valid finding crosses at least one trust boundary:

- Unauthenticated → Authenticated data
- Regular user → Another user's data (IDOR)
- User input → Server-side execution (RCE/SSRF/SSTI)
- Client → Internal network (SSRF)
- User role → Admin function (privilege escalation)

**If no trust boundary is crossed → the impact is likely negligible → discard.**

## Step 5 — Explicit Required Attacker Permissions

State clearly:
- [ ] None (unauthenticated)
- [ ] Valid account required
- [ ] Specific role required (what role?)
- [ ] Physical access required
- [ ] Victim interaction required (how likely?)
- [ ] MitM position required

If requirements are too high → downgrade severity; if impossible in real world → discard.

## Confidence Rating

| Confidence | Criteria |
|---|---|
| **Confirmed** | User has run the PoC and provided real response showing successful exploitation |
| **Probable** | Exploit path is clear, no known defense blocks it, code/logic analysis confirms |
| **Theoretical** | Exploit path exists but runtime verification is needed; user hasn't run it yet |

## When to Suggest Verification

If Theoretical, suggest the exact test for the user to run:

Use quoted text or prefixing with `Example:` — do NOT put runnable commands in code blocks.

After user provides real output:
- **Success output** → upgrade to Confirmed, proceed to report
- **Error/blocked output** → analyze the defense, downgrade or suggest bypass
- **Ambiguous output** → ask for more context before deciding

## Downgrade Triggers

Downgrade severity (not discard) when:
- Impact is real but scope is limited (single user, low-sensitivity data)
- Exploitation requires non-trivial victim interaction
- Partial bypass exists but not full control

Discard entirely when:
- Exploit path breaks at any validation/encoding/parameterization step
- Framework-level protection is confirmed active
- Impact is limited to the attacker's own account (self-impact only)
- Requires unrealistic attacker position (MitM on HTTPS, physical access)
