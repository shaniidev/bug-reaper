#!/usr/bin/env python3
"""
generate_report.py — Web2 Bug Bounty Report Generator

Generates a formatted vulnerability report for any major bug bounty platform.
Takes structured finding data and outputs a ready-to-submit Markdown report.

Usage:
    python generate_report.py --platform <platform> --vuln-type <type> --input findings.json
    python generate_report.py --platform hackerone --vuln-type xss --interactive
    python generate_report.py --help

Example:
    python generate_report.py --platform hackerone --vuln-type idor --input finding.json --output report.md
    python generate_report.py --platform bugcrowd --vuln-type sqli --interactive

Platforms: hackerone, bugcrowd, intigriti, yeswehack
Vuln types: xss, sqli, ssrf, idor, auth, biz-logic, rce, lfi, xxe, ssti, open-redirect,
         cors, csrf, subdomain-takeover, prototype-pollution, http-smuggling, api-graphql,
         nosqli
"""

import re
import json
import sys
import argparse
from datetime import datetime
from pathlib import Path

# ─── Platform Templates ────────────────────────────────────────────────────────

HACKERONE_TEMPLATE = """# {vuln_type_display}: {title}

## Summary
{summary}

## Impact
- **Security property violated:** {cia_impact}
- **Attacker achieves:** {attacker_achieves}
- **Who is affected:** {affected_scope}
- **Worst case:** {worst_case}

## Steps to Reproduce

{steps}

## Proof of Concept

```
{poc}
```

## Root Cause
{root_cause}

## Remediation
{remediation}

---
*Reported via web2-bug-bounty skill | {date}*
"""

BUGCROWD_TEMPLATE = """## Summary
{summary}

## Technical Details
**Vulnerable Endpoint:** `{endpoint}`
**Input Vector:** {input_vector}
**Missing Control:** {missing_control}
**Why Exploitable:** {why_exploitable}

## Steps to Reproduce

{steps}

## Proof of Concept

```
{poc}
```

## Impact
- **Attacker capability:** {attacker_achieves}
- **Data exposure:** {data_exposure}
- **Privilege escalation:** {priv_escalation}
- **Business risk:** {business_risk}

## CWE Classification
**{cwe}**
{cwe_reason}

## Remediation
{remediation}

---
*Generated by web2-bug-bounty skill | {date}*
"""

INTIGRITI_TEMPLATE = """### Description
{summary}

*Affected Component:* `{endpoint}`

### Technical Analysis

**How the vulnerability works:**
{how_it_works}

**Why the security control fails:**
{why_control_fails}

**Trust boundary violated:**
{trust_boundary}

### Steps to Reproduce

{steps}

### Proof of Concept

```
{poc}
```

### Impact

**Data exposure / Access escalation:**
{attacker_achieves}

**Attack preconditions:**
{prerequisites}

**Realistic abuse scenario:**
{realistic_scenario}

### Recommendation
{remediation}

---
*web2-bug-bounty | {date}*
"""

YESWEHACK_TEMPLATE = """# Vulnerability Overview
{summary}

# Affected Endpoint / Component
**Endpoint:** `{endpoint}`
**Component:** {component}

# Technical Details

**Root cause:**
{root_cause}

**Exploit mechanism:**
{how_it_works}

**Security assumption broken:**
{trust_boundary}

# Steps to Reproduce

{steps}

# Proof of Concept

```
{poc}
```

# Security Impact

**Confidentiality:** {confidentiality}
**Integrity:** {integrity}
**Availability:** {availability}

**Practical attack scenario:**
{realistic_scenario}

**Worst-case business outcome:**
{worst_case}

# Suggested Fix
{remediation}

---
*web2-bug-bounty | {date}*
"""

# ─── Vulnerability Type Metadata ──────────────────────────────────────────────

VULN_META = {
    "xss": {
        "display": "Cross-Site Scripting (XSS)",
        "cwe": "CWE-79: Improper Neutralization of Input During Web Page Generation",
        "default_cia": "Confidentiality (session tokens), Integrity (page content)",
    },
    "sqli": {
        "display": "SQL Injection",
        "cwe": "CWE-89: Improper Neutralization of Special Elements Used in SQL Command",
        "default_cia": "Confidentiality (database data), Integrity (data modification)",
    },
    "ssrf": {
        "display": "Server-Side Request Forgery (SSRF)",
        "cwe": "CWE-918: Server-Side Request Forgery",
        "default_cia": "Confidentiality (internal service access, cloud credentials)",
    },
    "idor": {
        "display": "Insecure Direct Object Reference (IDOR)",
        "cwe": "CWE-639: Authorization Bypass Through User-Controlled Key",
        "default_cia": "Confidentiality (other users' data), Integrity (unauthorized modification)",
    },
    "auth": {
        "display": "Authentication/Authorization Bypass",
        "cwe": "CWE-287: Improper Authentication",
        "default_cia": "Confidentiality, Integrity (full account compromise)",
    },
    "biz-logic": {
        "display": "Business Logic Vulnerability",
        "cwe": "CWE-840: Business Logic Errors",
        "default_cia": "Integrity (price manipulation, workflow bypass), Financial impact",
    },
    "rce": {
        "display": "Remote Code Execution (RCE)",
        "cwe": "CWE-78: OS Command Injection / CWE-94: Code Injection",
        "default_cia": "Confidentiality, Integrity, Availability (full server compromise)",
    },
    "lfi": {
        "display": "Local File Inclusion (LFI) / Path Traversal",
        "cwe": "CWE-22: Improper Limitation of a Pathname to a Restricted Directory",
        "default_cia": "Confidentiality (file system access, credentials)",
    },
    "open-redirect": {
        "display": "Open Redirect",
        "cwe": "CWE-601: URL Redirection to Untrusted Site",
        "default_cia": "Integrity (trust abuse), potential phishing chain",
    },
    "ssti": {
        "display": "Server-Side Template Injection (SSTI)",
        "cwe": "CWE-94: Improper Control of Generation of Code",
        "default_cia": "Confidentiality, Integrity, Availability (RCE potential)",
    },
    "xxe": {
        "display": "XML External Entity Injection (XXE)",
        "cwe": "CWE-611: Improper Restriction of XML External Entity Reference",
        "default_cia": "Confidentiality (file read, SSRF via XML)",
    },
    "cors": {
        "display": "CORS Misconfiguration",
        "cwe": "CWE-346: Origin Validation Error",
        "default_cia": "Confidentiality (cross-origin credential and data theft)",
    },
    "csrf": {
        "display": "Cross-Site Request Forgery (CSRF)",
        "cwe": "CWE-352: Cross-Site Request Forgery",
        "default_cia": "Integrity (unauthorized state change on behalf of victim)",
    },
    "subdomain-takeover": {
        "display": "Subdomain Takeover",
        "cwe": "CWE-350: Reliance on Reverse DNS Resolution for Security-Critical Action",
        "default_cia": "Integrity (attacker controls content under trusted domain), Confidentiality (cookie theft)",
    },
    "prototype-pollution": {
        "display": "Prototype Pollution",
        "cwe": "CWE-1321: Improperly Controlled Modification of Object Prototype Attributes",
        "default_cia": "Integrity (property injection), potential Confidentiality and RCE via gadget chains",
    },
    "http-smuggling": {
        "display": "HTTP Request Smuggling",
        "cwe": "CWE-444: Inconsistent Interpretation of HTTP Requests",
        "default_cia": "Confidentiality (capture victim requests), Integrity (bypass access controls)",
    },
    "api-graphql": {
        "display": "API / GraphQL Security Issue",
        "cwe": "CWE-285: Improper Authorization",
        "default_cia": "Confidentiality (unauthorized data access), Integrity (unauthorized modification)",
    },
    "nosqli": {
        "display": "NoSQL Injection",
        "cwe": "CWE-943: Improper Neutralization of Special Elements in Data Query Logic",
        "default_cia": "Confidentiality (data extraction), Authentication Bypass (full account compromise)",
    },
}

# ─── Helpers ──────────────────────────────────────────────────────────────────

def load_finding(input_file: str) -> dict:
    """Load finding data from JSON file."""
    path = Path(input_file)
    if not path.exists():
        print(f"Error: Input file not found: {input_file}", file=sys.stderr)
        sys.exit(1)
    try:
        return json.loads(path.read_text(encoding="utf-8"))
    except json.JSONDecodeError as e:
        print(f"Error: Invalid JSON in {input_file}: {e}", file=sys.stderr)
        sys.exit(1)


def interactive_collect() -> dict:
    """Collect finding data interactively from user prompts."""
    print("\n=== Web2 Bug Bounty Report Generator (Interactive Mode) ===\n")
    print("Enter finding details (press Enter to skip optional fields):\n")
    
    data = {}
    
    fields = [
        ("title", "Finding Title (e.g., Stored XSS in Profile Bio)", True),
        ("endpoint", "Vulnerable Endpoint (e.g., POST /api/user/profile)", True),
        ("summary", "Brief Technical Summary", True),
        ("steps", "Steps to Reproduce (one per line, blank line to finish)", True),
        ("poc", "Proof of Concept Payload/Request", True),
        ("root_cause", "Root Cause", True),
        ("remediation", "Remediation", True),
        ("attacker_achieves", "What Attacker Achieves", True),
        ("affected_scope", "Who is Affected", False),
        ("worst_case", "Worst Case Scenario", False),
        ("cia_impact", "CIA Impact (Confidentiality/Integrity/Availability)", False),
        ("input_vector", "Input Vector (parameter/header/field name)", False),
        ("missing_control", "Missing Security Control", False),
        ("data_exposure", "Data Exposed", False),
        ("business_risk", "Business Risk", False),
        ("trust_boundary", "Trust Boundary Violated", False),
        ("realistic_scenario", "Realistic Attack Scenario", False),
        ("component", "Component/Feature Name", False),
        ("prerequisites", "Attack Prerequisites", False),
    ]
    
    for field_name, prompt, required in fields:
        if field_name == "steps":
            print(f"{prompt}:")
            steps_lines = []
            step_num = 1
            while True:
                line = input(f"  Step {step_num}: ").strip()
                if not line:
                    break
                steps_lines.append(f"{step_num}. {line}")
                step_num += 1
            data[field_name] = "\n".join(steps_lines) if steps_lines else "1. [Steps to reproduce]"
        else:
            marker = " *" if required else ""
            value = input(f"{prompt}{marker}: ").strip()
            if value:
                data[field_name] = value
    
    return data


def format_steps(steps_input) -> str:
    """Format steps as numbered markdown list."""
    if isinstance(steps_input, list):
        return "\n".join(f"{i+1}. {step}" for i, step in enumerate(steps_input))
    elif isinstance(steps_input, str):
        # Already formatted or needs numbering
        lines = [l.strip() for l in steps_input.strip().split("\n") if l.strip()]
        formatted = []
        for i, line in enumerate(lines):
            if re.match(r"^\d+\.", line):
                formatted.append(line)
            else:
                formatted.append(f"{i+1}. {line}")
        return "\n".join(formatted)
    return "1. [Steps to reproduce not provided]"


def get_field(data: dict, field: str, default: str = "[Not provided]") -> str:
    """Safely get a field value with a default."""
    return data.get(field, default) or default


# ─── Report Generators ────────────────────────────────────────────────────────

def generate_hackerone(data: dict, vuln_type: str) -> str:
    meta = VULN_META.get(vuln_type, {"display": vuln_type.upper(), "cwe": "", "default_cia": ""})
    import re
    return HACKERONE_TEMPLATE.format(
        vuln_type_display=meta["display"],
        title=get_field(data, "title"),
        summary=get_field(data, "summary"),
        cia_impact=get_field(data, "cia_impact", meta["default_cia"]),
        attacker_achieves=get_field(data, "attacker_achieves"),
        affected_scope=get_field(data, "affected_scope", "All authenticated users"),
        worst_case=get_field(data, "worst_case"),
        steps=format_steps(get_field(data, "steps")),
        poc=get_field(data, "poc"),
        root_cause=get_field(data, "root_cause"),
        remediation=get_field(data, "remediation"),
        date=datetime.now().strftime("%Y-%m-%d"),
    )


def generate_bugcrowd(data: dict, vuln_type: str) -> str:
    meta = VULN_META.get(vuln_type, {"display": vuln_type.upper(), "cwe": "CWE-XXX", "default_cia": ""})
    return BUGCROWD_TEMPLATE.format(
        summary=get_field(data, "summary"),
        endpoint=get_field(data, "endpoint"),
        input_vector=get_field(data, "input_vector", "[User-controlled parameter]"),
        missing_control=get_field(data, "missing_control", "[Missing security control]"),
        why_exploitable=get_field(data, "root_cause"),
        steps=format_steps(get_field(data, "steps")),
        poc=get_field(data, "poc"),
        attacker_achieves=get_field(data, "attacker_achieves"),
        data_exposure=get_field(data, "data_exposure", get_field(data, "attacker_achieves")),
        priv_escalation=get_field(data, "priv_escalation", "N/A"),
        business_risk=get_field(data, "business_risk", get_field(data, "worst_case")),
        cwe=meta["cwe"],
        cwe_reason=f"This vulnerability fits {meta['cwe'].split(':')[0]} because the application " +
                   f"fails to properly control access to {get_field(data, 'endpoint', 'the affected resource')}.",
        remediation=get_field(data, "remediation"),
        date=datetime.now().strftime("%Y-%m-%d"),
    )


def generate_intigriti(data: dict, vuln_type: str) -> str:
    return INTIGRITI_TEMPLATE.format(
        summary=get_field(data, "summary"),
        endpoint=get_field(data, "endpoint"),
        how_it_works=get_field(data, "root_cause"),
        why_control_fails=get_field(data, "missing_control", "[Security control that should prevent this is absent or bypassed]"),
        trust_boundary=get_field(data, "trust_boundary", "[Trust boundary violated in this finding]"),
        steps=format_steps(get_field(data, "steps")),
        poc=get_field(data, "poc"),
        attacker_achieves=get_field(data, "attacker_achieves"),
        prerequisites=get_field(data, "prerequisites", "Standard user account"),
        realistic_scenario=get_field(data, "realistic_scenario", get_field(data, "attacker_achieves")),
        remediation=get_field(data, "remediation"),
        date=datetime.now().strftime("%Y-%m-%d"),
    )


def generate_yeswehack(data: dict, vuln_type: str) -> str:
    cia = get_field(data, "cia_impact", "")
    conf = "Impacted" if "confidentiality" in cia.lower() or "data" in cia.lower() else "Not impacted"
    integ = "Impacted" if "integrity" in cia.lower() or "modif" in cia.lower() else "Not impacted"
    avail = "Impacted" if "availability" in cia.lower() or "dos" in cia.lower() else "Not impacted"
    
    return YESWEHACK_TEMPLATE.format(
        summary=get_field(data, "summary"),
        endpoint=get_field(data, "endpoint"),
        component=get_field(data, "component", "[Affected component]"),
        root_cause=get_field(data, "root_cause"),
        how_it_works=get_field(data, "root_cause"),
        trust_boundary=get_field(data, "trust_boundary", "[Trust boundary violated]"),
        steps=format_steps(get_field(data, "steps")),
        poc=get_field(data, "poc"),
        confidentiality=get_field(data, "confidentiality", conf),
        integrity=get_field(data, "integrity", integ),
        availability=get_field(data, "availability", avail),
        realistic_scenario=get_field(data, "realistic_scenario", get_field(data, "attacker_achieves")),
        worst_case=get_field(data, "worst_case"),
        remediation=get_field(data, "remediation"),
        date=datetime.now().strftime("%Y-%m-%d"),
    )


# ─── Main ─────────────────────────────────────────────────────────────────────

GENERATORS = {
    "hackerone": generate_hackerone,
    "bugcrowd": generate_bugcrowd,
    "intigriti": generate_intigriti,
    "yeswehack": generate_yeswehack,
}

# ─── Main entry point ─────────────────────────────────────────────────────────


def main():
    parser = argparse.ArgumentParser(
        description="Generate a formatted bug bounty report for any major platform.",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Finding JSON format:
  {
    "title": "Stored XSS in Profile Bio",
    "endpoint": "POST /api/user/profile",
    "summary": "The /api/user/profile endpoint...",
    "steps": ["Log in", "Navigate to profile", "Enter payload"],
    "poc": "POST /api/user/profile HTTP/1.1\\n...\\n\\n{\"bio\": \"<script>...\"}",
    "root_cause": "User input is stored without sanitization...",
    "remediation": "Apply HTML encoding before output...",
    "attacker_achieves": "Execute arbitrary JS in victim's browser session",
    "trust_boundary": "User input -> HTML rendering for other users"
  }

Examples:
  python generate_report.py --platform hackerone --vuln-type xss --input finding.json
  python generate_report.py --platform bugcrowd --vuln-type sqli --interactive
  python generate_report.py --platform intigriti --vuln-type idor --input data.json --output report.md
        """
    )
    parser.add_argument("--platform", "-p",
        choices=list(GENERATORS.keys()),
        required=True,
        help="Target bug bounty platform"
    )
    parser.add_argument("--vuln-type", "-t",
        choices=list(VULN_META.keys()),
        required=True,
        help="Vulnerability type"
    )
    parser.add_argument("--input", "-i",
        help="Path to JSON file with finding data"
    )
    parser.add_argument("--interactive", "-I",
        action="store_true",
        help="Collect finding data interactively"
    )
    parser.add_argument("--output", "-o",
        help="Output Markdown file path (default: print to stdout)"
    )
    parser.add_argument("--list-fields",
        action="store_true",
        help="List all supported JSON fields and exit"
    )
    
    args = parser.parse_args()
    
    if args.list_fields:
        print("\nSupported JSON input fields:")
        fields = [
            ("title", "Required", "Short finding title"),
            ("endpoint", "Required", "Vulnerable endpoint (METHOD /path)"),
            ("summary", "Required", "Technical summary paragraph"),
            ("steps", "Required", "List of strings or newline-separated string"),
            ("poc", "Required", "PoC request/payload (raw HTTP or payload string)"),
            ("root_cause", "Required", "Root cause explanation"),
            ("remediation", "Required", "Recommended fix"),
            ("attacker_achieves", "Required", "Concrete attacker capability"),
            ("cia_impact", "Optional", "CIA properties violated"),
            ("affected_scope", "Optional", "Who is affected"),
            ("worst_case", "Optional", "Worst-case scenario"),
            ("input_vector", "Optional", "Parameter/header name"),
            ("missing_control", "Optional", "Security control that is absent"),
            ("data_exposure", "Optional", "Data type exposed"),
            ("priv_escalation", "Optional", "Privilege gained"),
            ("business_risk", "Optional", "Business impact"),
            ("trust_boundary", "Optional", "Trust boundary violated"),
            ("realistic_scenario", "Optional", "Single realistic attack narrative"),
            ("component", "Optional", "Feature/module name"),
            ("prerequisites", "Optional", "Attacker requirements"),
            ("confidentiality", "Optional", "'Impacted' or 'Not impacted'"),
            ("integrity", "Optional", "'Impacted' or 'Not impacted'"),
            ("availability", "Optional", "'Impacted' or 'Not impacted'"),
        ]
        for name, req, desc in fields:
            print(f"  {name:<20} [{req}] {desc}")
        print()
        return
    
    if not args.input and not args.interactive:
        parser.error("--input or --interactive is required")
    
    if args.interactive:
        data = interactive_collect()
    else:
        data = load_finding(args.input)
    
    generator = GENERATORS[args.platform]
    report = generator(data, args.vuln_type)
    
    if args.output:
        Path(args.output).write_text(report, encoding="utf-8")
        print(f"Report saved to: {args.output}")
        print(f"Platform: {args.platform.upper()} | Type: {VULN_META[args.vuln_type]['display']}")
    else:
        print(report)


if __name__ == "__main__":
    main()
